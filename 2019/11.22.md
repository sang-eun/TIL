# 11월 22일 회고
## 부스트캠프
- 지금까지 한 개발에 대해 데모를 진행하였다. 아직 구현해야 할 기능이 많이 남아있기에 마음은 촉박했지만 앞에 일이 머지가 되지 않은 이상 다음 피처를 진행할 마음이 들지 않았다. 또한 하던 피처도 계속 진행해도 나중에 머지된 코드를 보고 그와 비슷하게 수정할 테니 의미가 없는 것처럼 느껴졌다. 따라서 다음에는 피처를 분리하기로 마음을 먹었다.
- 그때문인지 오늘은 집중을 잘 하지 못한 것 같다.
- 주말동안에는 현재 피처와 크게 관련되지 않는 ci/cd에 전념하려고 한다. 

## 일과 후 공부
### git 정리
#### rebase vs merge

- merge

![](https://i.imgur.com/ghmlD2I.png)

위의 예시에서 feature1은 develop 브랜치에 머지를 한 경우이다. 따라서 feature1의 커밋들은 모두 고스란히 develop 브랜치에 남게 되고, 충돌이 있다면 머지 커밋까지 생겨 지저분하게 보인다.

그 다음에는 feature2에 feature1 git pull을 받는다(머지를 진행) 이 상태에서 feature2에서 develop으로 pull request를 날린다면, feature2와는 관계없는 feature1 관련 커밋까지 모두 들어가게 된다. 이처럼 머지 자체는 간단하지만 풀리퀘 커밋이 매우 많고, 지저분해 질 것이다.

- rebase

![](https://i.imgur.com/lxQ0csn.png)

반면에 이처럼 rebase feature2 onto develop을 실행하면
1. feature2의 베이스를 D에서 E로 바꾼다.
2. feature2의 커밋들 F21, F22, F23를 하나씩 돌면서 conflict를 해결하고 머지한다.
3. 결과적으로는 위와 같은 머지 커밋 없는 깔끔한 결과가 나오고, F21 F22 F23는 dangled pointer이 되어 reflog를 사용하지 않는 이상 돌아갈 수 없게 된다. (rebase이전으로 복구가 어렵다.)

따라서 풀리퀘에는 E 이후의 커밋만 나오므로, 깔끔하게 feature2관련 커밋만 볼 수 있다.

리베이스를 하도록 팀 규칙을 세우면, 커밋을 여러번 할 경우 리베이스가 귀찮아지므로(실제로 다른 프로젝트에서 많이 고통받았다..), 커밋을 덜 남기게 될 것 같다. 따라서 우리 팀은 조금 지저분하더라도 머지 체제로 가려고 한다.

#### squash
다른 프로젝트에서는 커밋 이력을 중요시하지 않아 develop에 머지할 때(develop이 거의 release 브랜치 수준이었음) squash를 하였는데, 자세히 작성한 커밋 이력들을 남기기 위해 이번 프로젝트에는 release 브랜치에 머지할 때 squash 커밋을 하고, develop에는 고스란히 올리려고 한다.

#### 특정 커밋만 머지하기 위해서
- cherry-pick
 특정 커밋을 가져오는데 매우 편리하게 쓰이지만, 해당 커밋에 더해 충돌이 날 경우 conflict 이력까지 남는 경우가 있어 비교적 지저분하다.
 - rebase -i
https://jupiny.com/2018/05/07/git-rebase-i-option/
conflict가 일어나도 관련 머지 이력이 남지 않아 마치 처음부터 그렇게 작성했던 것처럼 커밋을 가져올 수 있다. 하지만 cherry-pick보다 비교적 방식이 복잡하다.
