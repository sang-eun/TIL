# # 11월 15일 회고
## 부스트캠프
- 계속 미뤄졌던 db설계를 하였다.
   - 피드를 공유하는 관계인 share의 createdAt과 피드의 createdAt에 따라 피드를 정렬하려고 했다.       => 두 관계와 노드를 테이블처럼 고려하여 합치고 정렬을 하거나, 프로시저를 이용하자는 결론이 나왔다.
   - 노드를 테이블로, 관계를 relation으로 생각하여 맨 처음에 graphDB스럽지 않은 스키마가 나왔지만, 논의를 하면서 관계 또한 속성을 가질 수 있다는 생각으로 테이블이라고 고려하니 생략할 수 있는 노드가 많이 생겼다. 
- 이미지 업로드 모듈과 회원가입 api를 완성하였다. 후에 이미지 업로드 모듈은 sharp를 써서 크기별로 업로드 할 수 있도록 수정할 예정이다.
- 1차 제출한 이력서에 미흡한 부분이 있어서 수정하였다.

## 일과 후 공부
### MVC패턴
#### 작동 방식
![](https://i.imgur.com/6CZSX0J.png)
MVC 패턴은 위의 그림과 같은 구성을 가진다.

작동 순서는 이와 같다.
1. 유저가 (뷰 또는)컨트롤러를 통해 상호작용
2. 컨트롤러는 모델에게 알려 상태 변경
3. 모델은 상태가 변경되었다고 뷰에게 알림
4. 뷰는 모델로부터 새로운 상태를 받아와 업데이트된 뷰가 유저에게 보여짐

#### 컨트롤러
사용자가 입력한 것을 해석해서 그것을 바탕으로 모델을 조작
뷰에다가 그 기능을 넣을 수 있지만 뷰 코드가 복잡해지고 뷰와 모델의 의존성이 높아지는 문제때문에 둘을 분리하기 위해 컨트롤러가 존재한다.

#### 모델
옵저버 패턴: 상태가 변경될 경우 구독하고 있는 뷰들과 컨트롤러에게 알린다. 옵저버 패턴으로 분리되어 있으므로 모델은 뷰나 컨트롤러에게 전혀 의존하지 않는다.

#### 뷰
옵저버 패턴을 이용해 모델을 구독한다.
스트래티지 패턴: 컨트롤러는 어떤 상황에서 어떤 코드가 실행되어야 하는지를 가지고 있는 뷰의 전략 객체라고 할 수 있다. 따라서 뷰는 화면만 표시하면 되고 핵심 로직은 컨트롤러에서 처리한다.
컴포지트 패턴: 뷰는 GUI구성요소들로 구성되어 있다. 그 구성요소 하나하나들을 잎 노드라고 볼 수 있고, 그 상위 구성요소 또한 잎 노드라고 볼 수 있다.

직접 구현한다면
뷰는 상호작용이 들어오면 로직을 실행하기 위해 컨트롤러 인터페이스에 할당된 컨트롤러 구상 클래스를 호출할 것이다.
컨트롤러는 뷰와 모델을 가지고 로직을 처리하고, 상태를 업데이트 할 것이다.
모델은 뷰 구독자들을 가지고 상태를 변경한 뒤 구독자들에게 상태가 변경되었다는 것을 알릴 것이다.


#### 결론
모델과 컨트롤러, 뷰의 의존성을 떨어뜨리기 위한 패턴이다. 모델은 구독자들(뷰, 컨트롤러)을 가지고 있을 뿐 이 구독자 배열에 구독자가 추가되든, 삭제되든 영향을 받지 않는다(옵저버 패턴의 장점)
반면에 컨트롤러와 뷰의 의존성은 매우 높아지는 것 같다. 구현을 하려고 하면 어느부분까지 컨트롤러에서 처리하고 어느부분까지 뷰에서 처리해야 할 지 쉽게 구분되지 않을 듯 하다. 또한 뷰가 컨트롤러를 가지고, 컨트롤러는 뷰를 가지니 서로가 서로를 직접적으로 호출하여 이 부분도 매우 높은 의존도를 가진다고 할 수 있다.

하지만 인터넷에 검색해 보니 모델과 뷰의 의존도가 높아진다는 단점을 가진다고 한다. 헤드퍼스트 방식으로 옵저버를 통해 뷰가 모델을 구독하면 뷰가 모델을 직접적으로 호출하는 일이 없어지므로 단점이 보완된 듯 하다.



